package com.aviatorassist
import java.util.LinkedList
class AnalisadorPadroes(private val historicoCompleto:LinkedList<RegistroRodada>,private val limiteAzuis:Int=3){
fun verificarRiscoAtual(sequenciaRecente:List<TipoVela>):String{ var azuisConsecutivas=0; for(i in sequenciaRecente.indices.reversed()){ if(sequenciaRecente[i]==TipoVela.AZUL) azuisConsecutivas++ else break } if(azuisConsecutivas>limiteAzuis) return "‚ö†Ô∏è RISCO ALTO: $azuisConsecutivas Azuis consecutivas. N√ÉO RECOMENDADO." if(azuisConsecutivas==limiteAzuis) return "üö® ATEN√á√ÉO: $limiteAzuis Azuis consecutivas. Pr√≥xima entrada √© de alto risco." return "N√≠vel de Risco: Seguro ($azuisConsecutivas Azuis consecutivas)." }
fun analisarOportunidade(sequenciaRecente:List<TipoVela>):String{ if(verificarRiscoAtual(sequenciaRecente).contains("RISCO ALTO")) return "ANALISTA BLOQUEADO: Risco alto." val tamanhoPadrao=sequenciaRecente.size if(tamanhoPadrao<3) return "Aguardando mais √™nfase no padr√£o (m√≠n. 3 velas)." var ocorrenciasDeSucesso=0; var totalOcorrencias=0; for(i in 0 until historicoCompleto.size-tamanhoPadrao){ val fatia=historicoCompleto.subList(i,i+tamanhoPadrao).map{it.tipoVela}; if(fatia==sequenciaRecente){ totalOcorrencias++; val prox=historicoCompleto[i+tamanhoPadrao].tipoVela; if(prox==TipoVela.ROXO || prox==TipoVela.ROSA) ocorrenciasDeSucesso++; } } if(totalOcorrencias>0){ val porcentagem=(ocorrenciasDeSucesso.toDouble()/totalOcorrencias)*100; return "üìä OPORTUNIDADE: Padr√£o $totalOcorrencias vezes. Sucesso ${"%.1f".format(porcentagem)}%" } return "Nenhum padr√£o significativo." } }
